
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">yadro.com/course/api/adapters/auth/jwt.go (87.5%)</option>
				
				<option value="file1">yadro.com/course/api/adapters/limiter/limiter.go (100.0%)</option>
				
				<option value="file2">yadro.com/course/api/adapters/rest/api.go (0.0%)</option>
				
				<option value="file3">yadro.com/course/api/adapters/rest/middleware.go (0.0%)</option>
				
				<option value="file4">yadro.com/course/api/adapters/search/search.go (96.2%)</option>
				
				<option value="file5">yadro.com/course/api/adapters/update/update.go (97.0%)</option>
				
				<option value="file6">yadro.com/course/api/adapters/words/words.go (88.2%)</option>
				
				<option value="file7">yadro.com/course/api/config/config.go (0.0%)</option>
				
				<option value="file8">yadro.com/course/search/adapters/db/storage.go (0.0%)</option>
				
				<option value="file9">yadro.com/course/search/adapters/grpc/server.go (100.0%)</option>
				
				<option value="file10">yadro.com/course/search/adapters/timer/timer.go (100.0%)</option>
				
				<option value="file11">yadro.com/course/search/adapters/words/words.go (90.0%)</option>
				
				<option value="file12">yadro.com/course/search/config/config.go (0.0%)</option>
				
				<option value="file13">yadro.com/course/search/core/index.go (80.0%)</option>
				
				<option value="file14">yadro.com/course/search/core/service.go (94.8%)</option>
				
				<option value="file15">yadro.com/course/update/adapters/db/migrations.go (0.0%)</option>
				
				<option value="file16">yadro.com/course/update/adapters/db/storage.go (0.0%)</option>
				
				<option value="file17">yadro.com/course/update/adapters/grpc/server.go (100.0%)</option>
				
				<option value="file18">yadro.com/course/update/adapters/words/words.go (66.7%)</option>
				
				<option value="file19">yadro.com/course/update/adapters/xkcd/xkcd.go (87.5%)</option>
				
				<option value="file20">yadro.com/course/update/config/config.go (0.0%)</option>
				
				<option value="file21">yadro.com/course/update/core/service.go (100.0%)</option>
				
				<option value="file22">yadro.com/course/words/adapters/grpc/server.go (100.0%)</option>
				
				<option value="file23">yadro.com/course/words/adapters/stemming/snowball.go (100.0%)</option>
				
				<option value="file24">yadro.com/course/words/core/words.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
        "yadro.com/course/api/config"
        "yadro.com/course/api/core"
)

type JWTAuth struct {
        config config.AuthConfig
}

func NewJWTAuth(config config.AuthConfig) *JWTAuth <span class="cov10" title="9">{
        return &amp;JWTAuth{
                config: config,
        }
}</span>

func (a *JWTAuth) GenerateToken(username, password string) (string, error) <span class="cov6" title="4">{
        if username != a.config.AdminUser || password != a.config.AdminPassword </span><span class="cov3" title="2">{
                return "", core.ErrInvalidCredentials
        }</span>

        <span class="cov3" title="2">claims := jwt.MapClaims{
                "sub": "superuser",
                "exp": time.Now().Add(a.config.TokenTTL).Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(a.config.SecretKey))</span>
}

func (a *JWTAuth) ValidateToken(tokenString string) error <span class="cov7" title="5">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov5" title="3">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, core.ErrInvalidToken
                }</span>
                <span class="cov5" title="3">return []byte(a.config.SecretKey), nil</span>
        })

        <span class="cov7" title="5">if err != nil </span><span class="cov6" title="4">{
                return err
        }</span>

        <span class="cov1" title="1">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok || !token.Valid || claims["sub"] != "superuser" </span><span class="cov0" title="0">{
                return core.ErrInvalidToken
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package limiter

import (
        "time"

        "go.uber.org/ratelimit"
)

type ConcurrencyLimiter struct {
        sem chan struct{}
}

func NewConcurrencyLimiter(limit int) *ConcurrencyLimiter <span class="cov5" title="4">{
        return &amp;ConcurrencyLimiter{
                sem: make(chan struct{}, limit),
        }
}</span>

func (l *ConcurrencyLimiter) Acquire() bool <span class="cov10" title="16">{
        select </span>{
        case l.sem &lt;- struct{}{}:<span class="cov7" title="8">
                return true</span>
        default:<span class="cov7" title="8">
                return false</span>
        }
}

func (l *ConcurrencyLimiter) Release() <span class="cov7" title="8">{
        select </span>{
        case &lt;-l.sem:<span class="cov7" title="8"></span>
        default:<span class="cov0" title="0"></span>
        }
}

type RateLimiter struct {
        limiter ratelimit.Limiter
}

func NewRateLimiter(rps float64) *RateLimiter <span class="cov4" title="3">{
        return &amp;RateLimiter{
                limiter: ratelimit.New(int(rps), ratelimit.Per(time.Second)),
        }
}</span>

func (l *RateLimiter) Allow() bool <span class="cov7" title="8">{
        now := time.Now()
        next := l.limiter.Take()
        return next.Sub(now) &lt;= 0
}</span>

func (l *RateLimiter) Wait() <span class="cov4" title="3">{
        l.limiter.Take()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package rest

import (
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "strconv"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "yadro.com/course/api/core"
)

func NewPingHandler(log *slog.Logger, pingers map[string]core.Pinger) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                resp := make(map[string]string)
                for name, pinger := range pingers </span><span class="cov0" title="0">{
                        if err := pinger.Ping(r.Context()); err != nil </span><span class="cov0" title="0">{
                                resp[name] = "unavailable"
                        }</span> else<span class="cov0" title="0"> {
                                resp[name] = "ok"
                        }</span>
                }
                <span class="cov0" title="0">wrappedResp := map[string]interface{}{
                        "replies": resp,
                }
                err := json.NewEncoder(w).Encode(wrappedResp)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to encode response", "error", err)
                }</span>
        }
}

func NewWordsHandler(log *slog.Logger, normalizer core.Normalizer) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                phrase := r.URL.Query().Get("phrase")
                if phrase == "" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        fmt.Fprint(w, core.ErrBadArguments.Error())
                        return
                }</span>

                <span class="cov0" title="0">words, err := normalizer.Norm(r.Context(), phrase)
                if err != nil </span><span class="cov0" title="0">{
                        currStatus := http.StatusInternalServerError
                        if code := status.Code(err); code == codes.ResourceExhausted </span><span class="cov0" title="0">{
                                currStatus = http.StatusBadRequest
                                log.Debug("received message larger than 4KB", "phrase", phrase)
                        }</span> else<span class="cov0" title="0"> {
                                log.Error("failed to normalize phrase", "error", err)
                        }</span>
                        <span class="cov0" title="0">w.WriteHeader(currStatus)
                        fmt.Fprintf(w, "error normalizing phrase")
                        return</span>
                }

                <span class="cov0" title="0">response := map[string]interface{}{
                        "words": words,
                        "total": len(words),
                }
                err = json.NewEncoder(w).Encode(response)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to encode response", "error", err)
                }</span>
        }
}

func NewUpdateHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                err := updater.Update(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        if code := status.Code(err); code == codes.AlreadyExists </span><span class="cov0" title="0">{
                                log.Debug("already updating", "error", err)
                                w.WriteHeader(http.StatusAccepted)
                                return
                        }</span>
                        <span class="cov0" title="0">log.Error("failed to update", "error", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        fmt.Fprintf(w, "error updating")
                        return</span>
                }
        }
}

func NewUpdateStatsHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                stats, err := updater.Stats(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to get stats", "error", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        fmt.Fprintf(w, "error getting stats")
                        return
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "words_total":    stats.WordsTotal,
                        "words_unique":   stats.WordsUnique,
                        "comics_fetched": stats.ComicsFetched,
                        "comics_total":   stats.ComicsTotal,
                }
                err = json.NewEncoder(w).Encode(response)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to encode response", "error", err)
                }</span>
        }
}

func NewUpdateStatusHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                status, err := updater.Status(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to get status", "error", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        fmt.Fprintf(w, "error getting status")
                        return
                }</span>
                <span class="cov0" title="0">response := map[string]interface{}{
                        "status": status,
                }
                err = json.NewEncoder(w).Encode(response)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to encode response", "error", err)
                }</span>
        }
}

func NewDropHandler(log *slog.Logger, updater core.Updater) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                err := updater.Drop(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to drop", "error", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        fmt.Fprintf(w, "error dropping")
                        return
                }</span>
        }
}

func NewSearchHandler(log *slog.Logger, searcher core.Searcher) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                phrase := r.URL.Query().Get("phrase")
                limit := r.URL.Query().Get("limit")
                if phrase == "" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        fmt.Fprint(w, core.ErrBadArguments.Error())
                        return
                }</span>

                <span class="cov0" title="0">if limit == "" </span><span class="cov0" title="0">{
                        limit = "10"
                }</span>

                <span class="cov0" title="0">limitInt, err := strconv.Atoi(limit)
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        fmt.Fprint(w, core.ErrBadArguments.Error())
                        return
                }</span>

                <span class="cov0" title="0">if limitInt &lt; 0 </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        fmt.Fprint(w, core.ErrBadArguments.Error())
                        return
                }</span>

                <span class="cov0" title="0">comics, total, err := searcher.Search(r.Context(), phrase, limitInt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to search", "error", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        fmt.Fprintf(w, "error searching")
                        return
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "comics": comics,
                        "total":  total,
                }
                err = json.NewEncoder(w).Encode(response)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to encode response", "error", err)
                }</span>
        }
}

func NewISearchHandler(log *slog.Logger, searcher core.Searcher) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                phrase := r.URL.Query().Get("phrase")
                limit := r.URL.Query().Get("limit")
                if phrase == "" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        fmt.Fprint(w, core.ErrBadArguments.Error())
                        return
                }</span>

                <span class="cov0" title="0">if limit == "" </span><span class="cov0" title="0">{
                        limit = "10"
                }</span>

                <span class="cov0" title="0">limitInt, err := strconv.Atoi(limit)
                if err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        fmt.Fprint(w, core.ErrBadArguments.Error())
                        return
                }</span>

                <span class="cov0" title="0">if limitInt &lt; 0 </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        fmt.Fprint(w, core.ErrBadArguments.Error())
                        return
                }</span>

                <span class="cov0" title="0">comics, total, err := searcher.ISearch(r.Context(), phrase, limitInt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to search", "error", err)
                        w.WriteHeader(http.StatusInternalServerError)
                        fmt.Fprintf(w, "error searching")
                        return
                }</span>

                <span class="cov0" title="0">response := map[string]interface{}{
                        "comics": comics,
                        "total":  total,
                }
                err = json.NewEncoder(w).Encode(response)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to encode response", "error", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package rest

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "strings"

        "yadro.com/course/api/core"
)

type loginRequest struct {
        Name     string `json:"name"`
        Password string `json:"password"`
}

func WithAuth(auth core.Authenticator, log *slog.Logger) core.Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        authHeader := r.Header.Get("Authorization")
                        if authHeader == "" </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                        if len(parts) != 2 || parts[0] != "Token" </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">if err := auth.ValidateToken(parts[1]); err != nil </span><span class="cov0" title="0">{
                                log.Error("invalid token", "error", err)
                                w.WriteHeader(http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

func WithRateLimit(limiter core.RateLimiter, log *slog.Logger) core.Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        limiter.Wait()
                        next.ServeHTTP(w, r)
                }</span>)
        }
}

func WithConcurrencyLimit(limiter core.ConcurrencyLimiter, log *slog.Logger) core.Middleware <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if !limiter.Acquire() </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusServiceUnavailable)
                                log.Debug("concurrency limit exceeded")
                                return
                        }</span>
                        <span class="cov0" title="0">defer limiter.Release()
                        next.ServeHTTP(w, r)
                        log.Debug("concurrency limit released")</span>
                })
        }
}

func NewLoginHandler(auth core.Authenticator, log *slog.Logger) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                var req loginRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to decode login request", "error", err)
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">token, err := auth.GenerateToken(req.Name, req.Password)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to generate token", "error", err)
                        log.Info("admin user: %s, admin password: %s", req.Name, req.Password)
                        w.WriteHeader(http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "text/plain")
                _, err = w.Write([]byte(token))
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("failed to write token", "error", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package search

import (
        "context"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/protobuf/types/known/emptypb"
        "yadro.com/course/api/core"
        searchpb "yadro.com/course/proto/search"
)

type Client struct {
        log    *slog.Logger
        client searchpb.SearchClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov6" title="2">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return &amp;Client{
                log:    log,
                client: searchpb.NewSearchClient(conn),
        }, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov6" title="2">{
        _, err := c.client.Ping(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot ping search service", "error", err)
                return err
        }</span>

        <span class="cov1" title="1">c.log.Debug("pinged search service")
        return nil</span>
}

func (c Client) Search(ctx context.Context, phrase string, limit int) ([]core.Comics, int, error) <span class="cov10" title="3">{
        response, err := c.client.Search(ctx, &amp;searchpb.SearchRequest{
                Query: phrase,
                Limit: int64(limit),
        })
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot search comics", "error", err)
                return nil, 0, err
        }</span>

        <span class="cov6" title="2">comics := make([]core.Comics, 0, len(response.Items))
        for _, item := range response.Items </span><span class="cov6" title="2">{
                comics = append(comics, core.Comics{
                        ID:  item.Id,
                        URL: item.Url,
                })
        }</span>

        <span class="cov6" title="2">return comics, int(response.Total), nil</span>
}

func (c Client) ISearch(ctx context.Context, phrase string, limit int) ([]core.Comics, int, error) <span class="cov10" title="3">{
        response, err := c.client.ISearch(ctx, &amp;searchpb.ISearchRequest{
                Query: phrase,
                Limit: int64(limit),
        })
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot Isearch comics", "error", err)
                return nil, 0, err
        }</span>

        <span class="cov6" title="2">comics := make([]core.Comics, 0, len(response.Items))
        for _, item := range response.Items </span><span class="cov6" title="2">{
                comics = append(comics, core.Comics{
                        ID:  item.Id,
                        URL: item.Url,
                })
        }</span>
        <span class="cov6" title="2">return comics, int(response.Total), nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package update

import (
        "context"
        "errors"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/protobuf/types/known/emptypb"
        "yadro.com/course/api/core"
        updatepb "yadro.com/course/proto/update"
)

type Client struct {
        log    *slog.Logger
        client updatepb.UpdateClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov5" title="2">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="2">return &amp;Client{
                client: updatepb.NewUpdateClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov5" title="2">{
        _, err := c.client.Ping(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot ping update service", "error", err)
                return err
        }</span>

        <span class="cov1" title="1">c.log.Debug("pinged update service")
        return nil</span>
}

func (c Client) Status(ctx context.Context) (core.UpdateStatus, error) <span class="cov10" title="4">{
        status, err := c.client.Status(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot get update service status", "error", err)
                return core.StatusUpdateUnknown, err
        }</span>

        <span class="cov8" title="3">switch status.Status </span>{
        case updatepb.Status_STATUS_RUNNING:<span class="cov1" title="1">
                return core.StatusUpdateRunning, nil</span>
        case updatepb.Status_STATUS_IDLE:<span class="cov1" title="1">
                return core.StatusUpdateIdle, nil</span>
        }

        <span class="cov1" title="1">return core.StatusUpdateUnknown, errors.New("unknown status")</span>
}

func (c Client) Stats(ctx context.Context) (core.UpdateStats, error) <span class="cov5" title="2">{
        stats, err := c.client.Stats(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot get update service stats", "error", err)
                return core.UpdateStats{}, err
        }</span>

        <span class="cov1" title="1">return core.UpdateStats{
                WordsTotal:    int(stats.WordsTotal),
                WordsUnique:   int(stats.WordsUnique),
                ComicsTotal:   int(stats.ComicsTotal),
                ComicsFetched: int(stats.ComicsFetched),
        }, nil</span>

}

func (c Client) Update(ctx context.Context) error <span class="cov5" title="2">{
        _, err := c.client.Update(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot update update service", "error", err)
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (c Client) Drop(ctx context.Context) error <span class="cov5" title="2">{
        _, err := c.client.Drop(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot drop update service", "error", err)
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package words

import (
        "context"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/protobuf/types/known/emptypb"
        wordspb "yadro.com/course/proto/words"
)

type Client struct {
        log    *slog.Logger
        client wordspb.WordsClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov6" title="2">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                log.Error("cannot create grpc client", "error", err)
                return nil, err
        }</span>

        <span class="cov6" title="2">return &amp;Client{
                log:    log,
                client: wordspb.NewWordsClient(conn),
        }, nil</span>
}

func (c Client) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov10" title="3">{
        response, err := c.client.Norm(ctx, &amp;wordspb.WordsRequest{Phrase: phrase})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot normalize phrase", "error", err, "phrase", phrase)
                return nil, err
        }</span>

        <span class="cov6" title="2">c.log.Debug("got response from words service", "words", response.Words)

        return response.Words, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov6" title="2">{
        _, err := c.client.Ping(ctx, &amp;emptypb.Empty{})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("cannot ping words service", "error", err)
                return err
        }</span>

        <span class="cov1" title="1">c.log.Debug("pinged words service")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "log"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type HTTPConfig struct {
        Address string        `yaml:"address" env:"API_ADDRESS" env-default:"localhost:28080"`
        Timeout time.Duration `yaml:"timeout" env:"API_TIMEOUT" env-default:"5s"`
}

type AuthConfig struct {
        AdminUser     string        `yaml:"admin_user" env:"ADMIN_USER" env-default:"admin"`
        AdminPassword string        `yaml:"admin_password" env:"ADMIN_PASSWORD" env-default:"password"`
        TokenTTL      time.Duration `yaml:"token_ttl" env:"TOKEN_TTL" env-default:"2m"`
        SecretKey     string        `yaml:"jwt_secret" env:"JWT_SECRET" env-default:"dKJHSUDNI7b6*E#N(698MFD*#U98398m)"`
}

type Config struct {
        LogLevel          string     `yaml:"log_level" env:"LOG_LEVEL" env-default:"DEBUG"`
        HTTPConfig        HTTPConfig `yaml:"api_server"`
        WordsAddress      string     `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"words:81"`
        UpdateAddress     string     `yaml:"update_address" env:"UPDATE_ADDRESS" env-default:"update:82"`
        SearchAddress     string     `yaml:"search_address" env:"SEARCH_ADDRESS" env-default:"search:83"`
        AuthConfig        AuthConfig `yaml:"auth"`
        SearchRate        float64    `yaml:"search_rate" env:"SEARCH_RATE" env-default:"100"`
        SearchConcurrency int        `yaml:"search_concurrency" env:"SEARCH_CONCURRENCY" env-default:"10"`
}

func MustLoad(configPath string) Config <span class="cov0" title="0">{
        var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                if err := cleanenv.ReadEnv(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("cannot read config %q: %s", configPath, err)
                }</span>
        }
        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package db

import (
        "context"
        "log/slog"

        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
        "yadro.com/course/search/core"
)

type DB struct {
        log  *slog.Logger
        conn *sqlx.DB
}

func New(log *slog.Logger, address string) (*DB, error) <span class="cov0" title="0">{
        db, err := sqlx.Connect("pgx", address)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("connection problem", "address", address, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;DB{
                log:  log,
                conn: db,
        }, nil</span>
}

func (db *DB) Get(ctx context.Context, id int) (core.Comics, error) <span class="cov0" title="0">{
        var comic core.Comics
        err := db.conn.GetContext(ctx, &amp;comic, "SELECT comic_id as id, url, description FROM comics WHERE comic_id = $1", id)
        if err != nil </span><span class="cov0" title="0">{
                return core.Comics{}, core.ErrNotFound
        }</span>

        <span class="cov0" title="0">db.log.Debug("comics", "id", id)

        return comic, nil</span>
}

func (db *DB) IDs(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        var ids []int
        err := db.conn.SelectContext(ctx, &amp;ids, "SELECT comic_id FROM comics")
        if err != nil </span><span class="cov0" title="0">{
                return nil, core.ErrNotFound
        }</span>

        <span class="cov0" title="0">db.log.Debug("comics ids", "ids", ids)

        return ids, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package grpc

import (
        "context"
        "log/slog"

        "google.golang.org/protobuf/types/known/emptypb"
        searchpb "yadro.com/course/proto/search"
        "yadro.com/course/search/core"
)

type Server struct {
        searchpb.UnimplementedSearchServer
        service core.Searcher
}

func NewServer(service core.Searcher) *Server <span class="cov10" title="5">{
        return &amp;Server{service: service}
}</span>

func (s *Server) Ping(_ context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov1" title="1">{
        slog.Info("pinged search service")
        return nil, nil
}</span>

func (s *Server) Search(ctx context.Context, req *searchpb.SearchRequest) (*searchpb.ComicsResponse, error) <span class="cov4" title="2">{
        comics, total, err := s.service.Search(ctx, req.Query, int(req.Limit))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">pbComics := make([]*searchpb.Comics, len(comics))
        for i, c := range comics </span><span class="cov4" title="2">{
                pbComics[i] = &amp;searchpb.Comics{
                        Id:  int64(c.ID),
                        Url: c.URL,
                }
        }</span>

        <span class="cov1" title="1">return &amp;searchpb.ComicsResponse{
                Items: pbComics,
                Total: int64(total),
        }, nil</span>
}

func (s *Server) ISearch(ctx context.Context, req *searchpb.ISearchRequest) (*searchpb.ComicsResponse, error) <span class="cov4" title="2">{
        comics, total, err := s.service.ISearch(ctx, req.Query, int(req.Limit))
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">pbComics := make([]*searchpb.Comics, len(comics))
        for i, c := range comics </span><span class="cov4" title="2">{
                pbComics[i] = &amp;searchpb.Comics{
                        Id:  int64(c.ID),
                        Url: c.URL,
                }
        }</span>

        <span class="cov1" title="1">return &amp;searchpb.ComicsResponse{
                Items: pbComics,
                Total: int64(total),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package timer

import (
        "context"
        "time"

        "yadro.com/course/search/core"
)

type Timer struct {
        seconds int
        updater core.UpdateIndex
}

func New(seconds int, updater core.UpdateIndex) *Timer <span class="cov4" title="2">{
        return &amp;Timer{
                seconds: seconds,
                updater: updater,
        }
}</span>

func (t *Timer) Start(ctx context.Context) <span class="cov4" title="2">{
        t.updater.UpdateIndex(ctx)
        for </span><span class="cov10" title="6">{
                select </span>{
                case &lt;-time.After(time.Second * time.Duration(t.seconds)):<span class="cov7" title="4">
                        t.updater.UpdateIndex(ctx)</span>
                case &lt;-ctx.Done():<span class="cov4" title="2">
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package words

import (
        "context"
        "fmt"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        wordspb "yadro.com/course/proto/words"
)

type Client struct {
        log    *slog.Logger
        client wordspb.WordsClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov6" title="2">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return &amp;Client{
                client: wordspb.NewWordsClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov10" title="3">{
        response, err := c.client.Norm(ctx, &amp;wordspb.WordsRequest{Phrase: phrase})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("failed to normalize words", "error", err)
                return nil, fmt.Errorf("failed to normalize words: %w", err)
        }</span>

        <span class="cov6" title="2">c.log.Debug("words normalized", "words", response.Words)

        return response.Words, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package config

import (
        "log"

        "github.com/ilyakaznacheev/cleanenv"
)

type Config struct {
        LogLevel     string `yaml:"log_level" env:"LOG_LEVEL" env-default:"DEBUG"`
        Address      string `yaml:"search_address" env:"SEARCH_ADDRESS" env-default:"localhost:80"`
        WordsAddress string `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"localhost:82"`
        DBAddress    string `yaml:"db_address" env:"DB_ADDRESS" env-default:"postgres://postgres:password@postgres:5432/postgres"`
        TTL          int    `yaml:"ttl" env:"INDEX_TTL" env-default:"20"`
}

func MustLoad(configPath string) Config <span class="cov0" title="0">{
        var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                if err := cleanenv.ReadEnv(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("cannot read config %q: %s", configPath, err)
                }</span>
        }
        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package core

import (
        "context"
        "log/slog"
        "strings"
        "sync"
)

type Index struct {
        log     *slog.Logger
        db      DB
        mu      *sync.RWMutex
        entries map[string][]int
}

func NewIndex(log *slog.Logger, db DB) *Index <span class="cov10" title="7">{
        return &amp;Index{
                log:     log,
                db:      db,
                mu:      &amp;sync.RWMutex{},
                entries: make(map[string][]int),
        }
}</span>

func (i *Index) Search(word string) []int <span class="cov4" title="2">{
        i.mu.RLock()
        defer i.mu.RUnlock()
        return i.entries[word]
}</span>

func (i *Index) UpdateIndex(ctx context.Context) <span class="cov6" title="3">{
        i.mu.Lock()
        defer i.mu.Unlock()
        i.entries = make(map[string][]int)
        ids, err := i.db.IDs(ctx)
        if err != nil </span><span class="cov0" title="0">{
                i.log.Error("failed to get ids", "error", err)
                return
        }</span>

        <span class="cov6" title="3">for _, id := range ids </span><span class="cov4" title="2">{
                comics, err := i.db.Get(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        i.log.Error("failed to get comics", "error", err)
                        continue</span>
                }
                <span class="cov4" title="2">words := strings.Split(comics.Description, " ")
                i.add(words, id)</span>
        }
}

func (i *Index) add(phrase []string, comicsID int) <span class="cov4" title="2">{
        for _, word := range phrase </span><span class="cov9" title="6">{
                i.entries[word] = append(i.entries[word], comicsID)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package core

import (
        "context"
        "fmt"
        "log/slog"
        "sort"
        "strings"
)

type Service struct {
        log   *slog.Logger
        words Words
        index *Index
        db    DB
}

func NewService(log *slog.Logger, db DB, words Words, idx *Index) *Service <span class="cov10" title="7">{
        return &amp;Service{
                log:   log,
                words: words,
                db:    db,
                index: idx,
        }
}</span>

func (s *Service) Search(ctx context.Context, query string, limit int) ([]Comics, int, error) <span class="cov7" title="4">{
        if limit &lt;= 0 </span><span class="cov1" title="1">{
                return nil, 0, ErrBadArguments
        }</span>

        <span class="cov6" title="3">normQuery, err := s.words.Norm(ctx, query)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to normalize words: %w", err)
        }</span>

        <span class="cov4" title="2">comicIDToHits := make(map[int]int)
        ids, err := s.db.IDs(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to get ids: %w", err)
        }</span>

        <span class="cov1" title="1">for _, id := range ids </span><span class="cov4" title="2">{
                comics, err := s.db.Get(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to get comic: %w", err)
                }</span>
                <span class="cov4" title="2">for _, word := range normQuery </span><span class="cov7" title="4">{
                        if strings.Contains(comics.Description, word) </span><span class="cov7" title="4">{
                                comicIDToHits[id]++
                        }</span>
                }
        }

        <span class="cov1" title="1">type comicScore struct {
                ID    int
                Score int
        }
        var scoredComics []comicScore
        for id, score := range comicIDToHits </span><span class="cov4" title="2">{
                scoredComics = append(scoredComics, comicScore{id, score})
        }</span>
        <span class="cov1" title="1">sort.Slice(scoredComics, func(i, j int) bool </span><span class="cov1" title="1">{
                return scoredComics[i].Score &gt; scoredComics[j].Score
        }</span>)

        <span class="cov1" title="1">s.log.Debug("scoredComics", "scoredComics", scoredComics)

        resultComics := make([]Comics, 0, limit)
        for i := 0; i &lt; len(scoredComics) &amp;&amp; i &lt; limit; i++ </span><span class="cov4" title="2">{
                comics, err := s.db.Get(ctx, scoredComics[i].ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to fetch comic %d: %v", scoredComics[i].ID, err)
                }</span>
                <span class="cov4" title="2">resultComics = append(resultComics, comics)</span>
        }

        <span class="cov1" title="1">s.log.Debug("resultComics", "resultComics", resultComics)

        return resultComics, len(resultComics), nil</span>
}

func (s *Service) ISearch(ctx context.Context, query string, limit int) ([]Comics, int, error) <span class="cov6" title="3">{
        if limit &lt;= 0 </span><span class="cov1" title="1">{
                return nil, 0, ErrBadArguments
        }</span>

        <span class="cov4" title="2">uniqueWords, err := s.words.Norm(ctx, query)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, fmt.Errorf("failed to normalize words: %w", err)
        }</span>

        <span class="cov1" title="1">comicIDToHits := make(map[int]int)
        for _, word := range uniqueWords </span><span class="cov4" title="2">{
                comicIDs := s.index.Search(word)
                for _, id := range comicIDs </span><span class="cov7" title="4">{
                        comicIDToHits[id]++
                }</span>
        }

        <span class="cov1" title="1">s.log.Debug("comicIDToHits", "comicIDToHits", comicIDToHits)

        type comicScore struct {
                ID    int
                Score int
        }
        var scoredComics []comicScore
        for id, score := range comicIDToHits </span><span class="cov4" title="2">{
                scoredComics = append(scoredComics, comicScore{id, score})
        }</span>
        <span class="cov1" title="1">sort.Slice(scoredComics, func(i, j int) bool </span><span class="cov1" title="1">{
                return scoredComics[i].Score &gt; scoredComics[j].Score
        }</span>)

        <span class="cov1" title="1">s.log.Debug("scoredComics", "scoredComics", scoredComics)

        resultComics := make([]Comics, 0, limit)
        for i := 0; i &lt; len(scoredComics) &amp;&amp; i &lt; limit; i++ </span><span class="cov4" title="2">{
                comics, err := s.db.Get(ctx, scoredComics[i].ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to fetch comic %d: %v", scoredComics[i].ID, err)
                }</span>
                <span class="cov4" title="2">resultComics = append(resultComics, comics)</span>
        }

        <span class="cov1" title="1">s.log.Debug("resultComics", "resultComics", resultComics)

        return resultComics, len(resultComics), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package db

import (
        "embed"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/pgx"
        "github.com/golang-migrate/migrate/v4/source/iofs"
)

//go:embed migrations/*.sql
var migrationFiles embed.FS

func (db *DB) Migrate() error <span class="cov0" title="0">{
        db.log.Debug("running migration")
        files, err := iofs.New(migrationFiles, "migrations") // get migrations from
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">driver, err := pgx.WithInstance(db.conn.DB, &amp;pgx.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">m, err := migrate.NewWithInstance("iofs", files, "pgx", driver)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = m.Up()

        if err != nil </span><span class="cov0" title="0">{
                if err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                        db.log.Error("migration failed", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">db.log.Debug("migration did not change anything")</span>
        }

        <span class="cov0" title="0">db.log.Debug("migration finished")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package db

import (
        "context"
        "log/slog"
        "strings"

        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
        "yadro.com/course/update/core"
)

type DB struct {
        log  *slog.Logger
        conn *sqlx.DB
}

func New(log *slog.Logger, address string) (*DB, error) <span class="cov0" title="0">{
        db, err := sqlx.Connect("pgx", address)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("connection problem", "address", address, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;DB{
                log:  log,
                conn: db,
        }, nil</span>
}

func (db *DB) Add(ctx context.Context, comic core.Comics) error <span class="cov0" title="0">{
        query := `
                INSERT INTO comics (comic_id, url, description)
                VALUES ($1, $2, $3)
                ON CONFLICT (comic_id) DO UPDATE
                SET url = EXCLUDED.url,
                        description = EXCLUDED.description
        `

        _, err := db.conn.ExecContext(ctx, query, comic.ID, comic.URL, strings.Join(comic.Words, " "))
        if err != nil </span><span class="cov0" title="0">{
                db.log.Error("failed to insert comic",
                        "error", err,
                        "comic_id", comic.ID,
                        "words_count", len(comic.Words),
                        "url", comic.URL)
                return err
        }</span>

        <span class="cov0" title="0">db.log.Debug("comic added",
                "comic_id", comic.ID,
                "words_count", len(comic.Words),
                "url", comic.URL)

        return nil</span>
}

func (db *DB) Stats(ctx context.Context) (core.DBStats, error) <span class="cov0" title="0">{
        var stats core.DBStats

        err := db.conn.GetContext(ctx, &amp;stats.ComicsFetched, "SELECT COUNT(*) FROM comics")
        if err != nil </span><span class="cov0" title="0">{
                return core.DBStats{}, err
        }</span>

        <span class="cov0" title="0">db.log.Debug("comics fetched", "count", stats.ComicsFetched)

        var descriptions []string
        err = db.conn.SelectContext(ctx, &amp;descriptions, "SELECT description FROM comics WHERE description IS NOT NULL")
        if err != nil </span><span class="cov0" title="0">{
                return core.DBStats{}, err
        }</span>

        <span class="cov0" title="0">wordsMap := make(map[string]struct{})
        for _, desc := range descriptions </span><span class="cov0" title="0">{
                words := strings.Fields(desc)
                stats.WordsTotal += len(words)
                for _, word := range words </span><span class="cov0" title="0">{
                        wordsMap[word] = struct{}{}
                }</span>
        }
        <span class="cov0" title="0">stats.WordsUnique = len(wordsMap)

        db.log.Debug("words unique", "count", stats.WordsUnique)
        db.log.Debug("words total", "count", stats.WordsTotal)

        return stats, nil</span>
}

func (db *DB) IDs(ctx context.Context) ([]int, error) <span class="cov0" title="0">{
        var ids []int
        err := db.conn.SelectContext(ctx, &amp;ids, "SELECT comic_id FROM comics")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ids, nil</span>
}

func (db *DB) Drop(ctx context.Context) error <span class="cov0" title="0">{
        if _, err := db.conn.ExecContext(ctx, "TRUNCATE TABLE comics"); err != nil </span><span class="cov0" title="0">{
                db.log.Error("failed to truncate table", "error", err)
                return core.ErrTruncateTable
        }</span>

        <span class="cov0" title="0">db.log.Debug("table truncated")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package grpc

import (
        "context"
        "log/slog"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        updatepb "yadro.com/course/proto/update"
        "yadro.com/course/update/core"
)

func NewServer(service core.Updater) *Server <span class="cov10" title="11">{
        return &amp;Server{service: service}
}</span>

type Server struct {
        updatepb.UnimplementedUpdateServer
        service core.Updater
}

func (s *Server) Ping(_ context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov1" title="1">{
        slog.Info("pinged update service")
        return nil, nil
}</span>

func (s *Server) Status(ctx context.Context, _ *emptypb.Empty) (*updatepb.StatusReply, error) <span class="cov5" title="3">{
        serviceStatus := s.service.Status(ctx)

        switch serviceStatus </span>{
        case core.StatusRunning:<span class="cov1" title="1">
                return &amp;updatepb.StatusReply{Status: updatepb.Status_STATUS_RUNNING}, nil</span>
        case core.StatusIdle:<span class="cov1" title="1">
                return &amp;updatepb.StatusReply{Status: updatepb.Status_STATUS_IDLE}, nil</span>
        }

        <span class="cov1" title="1">return nil, status.Error(codes.Internal, "unknown status")</span>
}

func (s *Server) Update(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov5" title="3">{
        err := s.service.Update(ctx)
        if err != nil </span><span class="cov3" title="2">{
                if err == core.ErrAlreadyExists </span><span class="cov1" title="1">{
                        return nil, status.Error(codes.AlreadyExists, "update already in progress")
                }</span>
                <span class="cov1" title="1">return nil, status.Error(codes.Internal, "failed to update")</span>
        }
        <span class="cov1" title="1">return &amp;emptypb.Empty{}, nil</span>
}

func (s *Server) Stats(ctx context.Context, _ *emptypb.Empty) (*updatepb.StatsReply, error) <span class="cov3" title="2">{
        stats, err := s.service.Stats(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Internal, "failed to get stats")
        }</span>

        <span class="cov1" title="1">return &amp;updatepb.StatsReply{
                WordsTotal:    int64(stats.WordsTotal),
                WordsUnique:   int64(stats.WordsUnique),
                ComicsTotal:   int64(stats.ComicsTotal),
                ComicsFetched: int64(stats.ComicsFetched),
        }, nil</span>
}

func (s *Server) Drop(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) <span class="cov3" title="2">{
        err := s.service.Drop(ctx)
        if err != nil </span><span class="cov1" title="1">{
                return nil, status.Error(codes.Internal, "failed to drop data")
        }</span>

        <span class="cov1" title="1">return &amp;emptypb.Empty{}, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package words

import (
        "context"
        "log/slog"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        wordspb "yadro.com/course/proto/words"
)

type Client struct {
        log    *slog.Logger
        client wordspb.WordsClient
}

func NewClient(address string, log *slog.Logger) (*Client, error) <span class="cov0" title="0">{
        conn, err := grpc.NewClient(address, grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{
                client: wordspb.NewWordsClient(conn),
                log:    log,
        }, nil</span>
}

func (c Client) Norm(ctx context.Context, phrase string) ([]string, error) <span class="cov10" title="3">{
        response, err := c.client.Norm(ctx, &amp;wordspb.WordsRequest{Phrase: phrase})
        if err != nil </span><span class="cov1" title="1">{
                c.log.Error("failed to normalize words", "error", err)
                return nil, err
        }</span>

        <span class="cov6" title="2">c.log.Debug("words normalized", "words", response.Words)

        return response.Words, nil</span>
}

func (c Client) Ping(ctx context.Context) error <span class="cov6" title="2">{
        _, err := c.client.Ping(ctx, nil)
        return err
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package xkcd

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "time"

        "yadro.com/course/update/core"
)

type Client struct {
        log    *slog.Logger
        client http.Client
        url    string
}

func NewClient(url string, timeout time.Duration, log *slog.Logger) (*Client, error) <span class="cov10" title="9">{
        if url == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("empty base url specified")
        }</span>
        <span class="cov9" title="8">return &amp;Client{
                client: http.Client{Timeout: timeout},
                log:    log,
                url:    url,
        }, nil</span>
}

func (c Client) Get(ctx context.Context, id int) (core.XKCDInfo, error) <span class="cov6" title="4">{
        if id == 404 </span><span class="cov1" title="1">{
                c.log.Debug("skipping special comic 404")
                return core.XKCDInfo{
                        ID:          id,
                        Description: "Not found",
                        Title:       "404",
                }, nil
        }</span>
        <span class="cov5" title="3">resp, err := c.client.Get(c.url + fmt.Sprintf("/%d/info.0.json", id))
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("failed to get comic", "id", id, "error", err)
                return core.XKCDInfo{}, core.ErrNotFound
        }</span>
        <span class="cov5" title="3">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov1" title="1">{
                c.log.Error("unexpected status code", "status", resp.StatusCode)
                return core.XKCDInfo{}, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov3" title="2">info := struct {
                ID         int    `json:"num"`
                URL        string `json:"img"`
                Title      string `json:"title"`
                Alt        string `json:"alt"`
                SafeTitle  string `json:"safe_title"`
                Transcript string `json:"transcript"`
        }{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;info); err != nil </span><span class="cov1" title="1">{
                c.log.Error("failed to decode comic", "error", err)
                return core.XKCDInfo{}, fmt.Errorf("failed to decode comic: %w", err)
        }</span>

        <span class="cov1" title="1">c.log.Debug("got comic", "id", id, "title", info.Title)
        return core.XKCDInfo{
                ID:          info.ID,
                URL:         info.URL,
                Title:       info.Title,
                Description: info.Transcript + " " + info.Alt + " " + info.SafeTitle,
        }, nil</span>
}

func (c Client) LastID(ctx context.Context) (int, error) <span class="cov5" title="3">{
        resp, err := c.client.Get(c.url + "/info.0.json")
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("failed to get last id", "error", err)
                return 0, fmt.Errorf("failed to get last id: %w", err)
        }</span>
        <span class="cov5" title="3">defer resp.Body.Close()

        var info struct {
                Num int `json:"num"`
        }

        err = json.NewDecoder(resp.Body).Decode(&amp;info)
        if err != nil </span><span class="cov3" title="2">{
                c.log.Error("failed to decode last id", "error", err)
                return 0, fmt.Errorf("failed to decode last id: %w", err)
        }</span>

        <span class="cov1" title="1">c.log.Debug("last id", "id", info.Num)

        return info.Num, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package config

import (
        "log"
        "time"

        "github.com/ilyakaznacheev/cleanenv"
)

type XKCD struct {
        URL         string        `yaml:"url" env:"XKCD_URL" env-default:"xkcd.com"`
        Concurrency int           `yaml:"concurrency" env:"XKCD_CONCURRENCY" env-default:"1"`
        Timeout     time.Duration `yaml:"timeout" env:"XKCD_TIMEOUT" env-default:"10s"`
        CheckPeriod time.Duration `yaml:"check_period" env:"XKCD_CHECK_PERIOD" env-default:"1h"`
}

type Config struct {
        LogLevel     string `yaml:"log_level" env:"LOG_LEVEL" env-default:"DEBUG"`
        Address      string `yaml:"update_address" env:"UPDATE_ADDRESS" env-default:"localhost:80"`
        XKCD         XKCD   `yaml:"xkcd"`
        DBAddress    string `yaml:"db_address" env:"DB_ADDRESS" env-default:"localhost:82"`
        WordsAddress string `yaml:"words_address" env:"WORDS_ADDRESS" env-default:"localhost:81"`
}

func MustLoad(configPath string) Config <span class="cov0" title="0">{
        var cfg Config
        if err := cleanenv.ReadConfig(configPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                if err := cleanenv.ReadEnv(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("cannot read config %q: %s", configPath, err)
                }</span>
        }
        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package core

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
)

type Service struct {
        log         *slog.Logger
        db          DB
        xkcd        XKCD
        words       Words
        concurrency int
        mutex       sync.Mutex
}

func NewService(
        log *slog.Logger, db DB, xkcd XKCD, words Words, concurrency int,
) (*Service, error) <span class="cov8" title="20">{
        if concurrency &lt; 1 </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("wrong concurrency specified: %d", concurrency)
        }</span>
        <span class="cov8" title="18">return &amp;Service{
                log:         log,
                db:          db,
                xkcd:        xkcd,
                words:       words,
                concurrency: concurrency,
                mutex:       sync.Mutex{},
        }, nil</span>
}

func (s *Service) processComic(ctx context.Context, i int, semaphore chan struct{}, wg *sync.WaitGroup) <span class="cov9" title="32">{
        semaphore &lt;- struct{}{}
        defer func() </span><span class="cov9" title="32">{
                &lt;-semaphore
                wg.Done()
        }</span>()

        <span class="cov9" title="32">s.log.Debug("downloading comic", "id", i)
        comicsInfo, err := s.xkcd.Get(ctx, i)
        if err != nil </span><span class="cov7" title="15">{
                s.log.Error("failed to get comic", "error", err)
                return
        }</span>

        <span class="cov7" title="17">description := comicsInfo.Title + " " + comicsInfo.Description

        normedDescription, err := s.words.Norm(ctx, description)
        if err != nil </span><span class="cov4" title="5">{
                s.log.Error("failed to normalize words", "error", err)
                return
        }</span>

        <span class="cov7" title="12">err = s.db.Add(ctx, Comics{
                ID:    i,
                URL:   comicsInfo.URL,
                Words: normedDescription,
        })
        if err != nil </span><span class="cov4" title="5">{
                s.log.Error("failed to add comic", "error", err)
                return
        }</span>

        <span class="cov5" title="7">s.log.Debug("added comic", "id", i)</span>
}

func (s *Service) Update(ctx context.Context) (err error) <span class="cov6" title="11">{
        if !s.mutex.TryLock() </span><span class="cov1" title="1">{
                s.log.Debug("update already in progress")
                return ErrAlreadyExists
        }</span>
        <span class="cov6" title="10">defer s.mutex.Unlock()

        s.log.Debug("update started")

        comicsTotal, err := s.xkcd.LastID(ctx)
        if err != nil </span><span class="cov1" title="1">{
                s.log.Error("failed to get comics total", "error", err)
                return ErrComicsCount
        }</span>

        <span class="cov6" title="9">downloadedComics, err := s.db.IDs(ctx)
        if err != nil </span><span class="cov1" title="1">{
                s.log.Error("failed to get downloaded comics", "error", err)
                return ErrGetDownloadedComics
        }</span>

        <span class="cov6" title="8">downloadedComicsMap := make(map[int]struct{})
        for _, id := range downloadedComics </span><span class="cov6" title="8">{
                downloadedComicsMap[id] = struct{}{}
        }</span>

        <span class="cov6" title="8">s.log.Debug("downloaded comics", "count :", len(downloadedComicsMap))
        s.log.Debug("downloading comics", "count :", comicsTotal-len(downloadedComicsMap))

        semaphore := make(chan struct{}, s.concurrency)
        defer close(semaphore)
        wg := sync.WaitGroup{}
        for i := 1; i &lt;= comicsTotal; i++ </span><span class="cov10" title="40">{
                if _, ok := downloadedComicsMap[i]; ok </span><span class="cov6" title="8">{
                        continue</span>
                }
                <span class="cov9" title="32">wg.Add(1)
                go s.processComic(ctx, i, semaphore, &amp;wg)</span>
        }
        <span class="cov6" title="8">wg.Wait()
        return nil</span>
}

func (s *Service) Stats(ctx context.Context) (ServiceStats, error) <span class="cov3" title="3">{
        comicsTotal, err := s.xkcd.LastID(ctx)
        if err != nil </span><span class="cov1" title="1">{
                s.log.Error("failed to get comics total", "error", err)
                return ServiceStats{}, ErrComicsCount
        }</span>

        <span class="cov2" title="2">dbStats, err := s.db.Stats(ctx)
        if err != nil </span><span class="cov1" title="1">{
                s.log.Error("failed to get db stats", "error", err)
                return ServiceStats{}, ErrGetDBStats
        }</span>

        <span class="cov1" title="1">return ServiceStats{
                DBStats:     dbStats,
                ComicsTotal: comicsTotal,
        }, nil</span>
}

func (s *Service) Status(ctx context.Context) ServiceStatus <span class="cov3" title="3">{
        if !s.mutex.TryLock() </span><span class="cov1" title="1">{
                s.log.Debug("status already in progress")
                return StatusRunning
        }</span>
        <span class="cov2" title="2">s.mutex.Unlock()
        s.log.Debug("status idle")
        return StatusIdle</span>
}

func (s *Service) Drop(ctx context.Context) error <span class="cov2" title="2">{
        s.log.Debug("dropping db")
        return s.db.Drop(ctx)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package grpc

import (
        "context"
        "log/slog"
        "strconv"
        "time"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/emptypb"
        wordspb "yadro.com/course/proto/words"
        "yadro.com/course/words/core"
)

const (
        maxPhraseLen    = 20000
        maxShutdownTime = 10 * time.Second
)

type Server struct {
        wordspb.UnimplementedWordsServer
        words core.Normalizer
}

func New(words core.Normalizer) *Server <span class="cov10" title="4">{
        return &amp;Server{
                words: words,
        }
}</span>

func (s *Server) Ping(_ context.Context, in *emptypb.Empty) (*emptypb.Empty, error) <span class="cov1" title="1">{
        slog.Info("pinged words service")
        return nil, nil
}</span>

func (s *Server) Norm(_ context.Context, in *wordspb.WordsRequest) (*wordspb.WordsReply, error) <span class="cov8" title="3">{
        if len(in.GetPhrase()) &gt; maxPhraseLen </span><span class="cov1" title="1">{
                slog.Error("phrase is large than max phrase length", "phrase", in.GetPhrase(), "max phrase length", maxPhraseLen)
                return nil, status.Error(
                        codes.ResourceExhausted,
                        "phrase is large than "+strconv.Itoa(maxPhraseLen),
                )
        }</span>
        <span class="cov5" title="2">return &amp;wordspb.WordsReply{
                Words: s.words.Norm(in.GetPhrase()),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package stemming

import (
        "strings"

        "github.com/kljensen/snowball/english"
)

type Snowball struct{}

func (s Snowball) Stem(word string) string <span class="cov10" title="10">{
        word = strings.ToLower(word)
        if english.IsStopWord(word) </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov9" title="9">return english.Stem(word, false)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package core

import (
        "maps"
        "slices"
        "strings"
        "unicode"

        "log/slog"
)

type Words struct {
        stemmer Stemmer
}

func NewWords(stemmer Stemmer) Words <span class="cov4" title="7">{
        return Words{stemmer: stemmer}
}</span>

func (w Words) Norm(phrase string) []string <span class="cov4" title="7">{

        splitted := strings.FieldsFunc(phrase, func(r rune) bool </span><span class="cov10" title="86">{
                return !unicode.IsDigit(r) &amp;&amp; !unicode.IsLetter(r)
        }</span>)

        <span class="cov4" title="7">words := make(map[string]bool)
        for _, word := range splitted </span><span class="cov6" title="14">{
                stemmed := w.stemmer.Stem(word)
                if len(stemmed) &gt; 0 </span><span class="cov6" title="14">{
                        words[stemmed] = true
                }</span>
        }

        <span class="cov4" title="7">slog.Info("words normalized", "words", words)

        return slices.Collect(maps.Keys(words))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
